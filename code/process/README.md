### PHP进程

在php中我们使用pcntl_fork()来创建多进程（在*NIX系统的C语言编程中，已有进程通过调用fork函数来产生新的进程）。
fork出来新进程则成为子进程，原进程则成为父进程，子进程拥有父进程的副本。
这里要注意：

```angular2html

子进程与父进程共享程序正文段

子进程拥有父进程的数据空间和堆、栈的副本，注意是副本，不是共享

父进程和子进程将继续执行fork之后的程序代码

fork之后，是父进程先执行还是子进程先执行无法确认，取决于系统调度（取决于信仰）

```

这里说子进程拥有父进程数据空间以及堆、栈的副本，实际上，在大多数的实现中也并不是真正的完全副本。更多是采用了COW（Copy On Write）即写时复制的技术来节约存储空间。

简单来说，如果父进程和子进程都不修改这些 数据、堆、栈 的话，那么父进程和子进程则是暂时共享同一份 数据、堆、栈。只有当父进程或者子进程试图对 数据、堆、栈 进行修改的时候，才会产生复制操作，这就叫做写时复制。

在调用完pcntl_fork()后，该函数会返回两个值。在父进程中返回子进程的进程ID，在子进程内部本身返回数字0。由于多进程在apache或者fpm环境下无法正常运行，所以大家一定要在php cli环境下执行下面php代码。

第一段代码，我们来说明在程序从pcntl_fork()后父进程和子进程将各自继续往下执行代码:


### 信号

信号是一种软件中断，也是一种非常典型的异步事件处理方式。在 *nix 系统诞生的混沌之初，信号的定义是比较混乱的，而且最关键是不可靠，这是一个很严重的问题。

所以在后来的POSIX标准中，对信号做了标准化同时也各个发行版的 *nix 也都提供大量可靠的信号。

每种信号都有自己的名字，大概如SIGTERM、SIGHUP、SIGCHLD等等，在 *nix 中，这些信号本质上都是整形数字（游有心情的可以参观一下signal.h系列头文件）。